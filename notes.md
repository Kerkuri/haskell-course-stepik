# Книга "Программируй на Haskell" - Уилл Курт (для хлебушков)
## Урок 1. Начало работы с Haskell
### Базовая структура исполняемого кода на Haskell

* В проекте должен быть модуль Main, иначе компилятор не будет компилировать файл.
* Но при выполении кода через интерпретатор (ghci) название модуля может быть любым.

```haskell
module Main where

-- ! аналог main() из C++ и __main__ в Python
main = do
  putStrLn "Hello, Haskell!"

-- * можно скомпилировать файл в исполняемый через ghc <filename> (обязательно наличие main и Модуля main)
-- * а можно использовать из интерпретатора ghci: :load <filename> (название модуля может быть любым)
```


### Особенность написания кода в Haskell (Урок 1.4)
* Если вы привыкли быстро написать программу, запустить её, а потом по-быстрому исправить сделанные ошибки, то Haskell вас разочарует.
* **Haskell поощряет медитатив­ное сидение и обдумывание встреченных проблем до запуска программы!**
* После того как вы наберётесь опыта, мы уверены, это разочарование пре­вратится в вашу любимую особенность Haskell.
* Оборотной стороной одер­жимости корректностью на этапе компиляции является то, что ваши про­ граммы будут работать гораздо более предсказуемо, чем вы, возможно, привыкли.


>Секрет спокойного написания кода без частых столкновений с ошибками состоит в том, чтобы писать его маленькими кусочками и тестировать эти кусочки в процессе написания.


## Урок 2. Функции и функциональное программирование
* Заметьте, что, в отличие от многих других языков программирования, в Haskell вам не нужно уточнять, что вы возвращаете значение. 
* В Haskell **функции обязаны возвращать значение**, так что никогда не нужно указывать это явно.


### Все функции в Haskell следуют трем правилам:
1) Все функции должны принимать аргумент
2) Все функции должны возвращать значение
3) Функция возвращает одно и то же значение для одного и того же аргумента (ссылочная прозрачность)


### Haskell и лямбда-вычисление:
* Haskell основан на лямбда-исчислении (**TODO: разобраться, что это такое**)
* Лямбда-исчисление является универсальной моделью вычислений, эквивалентной машине Тьюринга (**TODO: разобраться, что это такое**)
> Машина Тьюринга —это абстрактная модель компьютера. С теоретической точки зрения машина Тьюринга полезна, потому что она позволяет рассуждать о том, что может или не может быть вычислено не только на цифровом компьютере, но на любом компьютере вообще.

### Haskell и математика:
- Абстракции большинства языков программирования ограничены инженерными решениями
- Haskell, будучи основан на математике, не имеет таких ограничений.
- Имея на руках возможность напрямую "программировать математику" (sic!), Haskell-программисты могут как математически доказывать работоспособность своего кода, так и пользоваться всей силой математических абстракций.

### Безопасность Haskell:
- Благодаря правилам, которым подчиняются функции в Haskell (всегда принимать и возвращать значение, всегда возвращать одно и то же значение для одного и того же аргумента), Haskell является **безопасным** языком программирования.
> Программы безопасны тогда, когда они ведут себя так, как вы ожидаете, и вы легко можете рассуждать об их поведении Безопасный язык программирования — тот, который заставляет ваши программы вести себя так, как ожидается.

### Переменные в Haskell 
- В отличие от других ЯП, переменные в Haskell можно определить в конце тела функции (ключевое слово `where`):
```haskell
calcChange owed given = max change 0
  where change = given - owed
```
- Переменные нельзя переприсваивать (можно в интерпретаторе GHCi):
```haskell
x = 2
x = 3 -- не скомпилируется
```
- Из-за того что все функции в Haskell обязаны возвращать значение, if-блок не может использоваться без else-блока


## Урок 3. Лямбда-функции и лексическая область видимости

### Лямбда-функции
- Синтаксис:
```haskell
\<variables> -> <body>
```

- Пример:
```haskell
\x -> 10 * x
```

- Фактически являются аналогом блока where:
```haskell

sumSquareOrSquareSum x y = max sumSquare squareSum
  where
    sumSquare = x^2 + y^2 
    squareSum = (x + y)^2

-- аналог с лямбдой:
sumSquareOrSquareSum x y = (\a b -> max a b) (x^2 + y^2) ((x + y)^2)
```
- Лямбда (в отличие от блока where) является выражением, то есть может существовать само по себе:
```haskell
lamF = (\x -> 10 * x)
xTenTimes x = lamF x
```

### let - альтернатива where:
- В let переменные идут ДО тела функции
- В некотором смысле являются чем-то средним между определением функции через блок where и лямбдой: наглядно как в where, мощно как в лямбде
> Выбор между where и let является, как правило, делом вкуса.

- Через let можно продемонстрировать, как примерно работает переопределение переменных в интерпреаторе (в Haskell такое нельзя - будет ошибка компиляции):
```haskell
overwrite x = let x = 2
  in let x = 3
    in let x = 4
      in x
```

## Урок 4. Функции как значения первого класса

- Функции можно передавать как аргументы других функций:
```haskell
ifEvenDo func x = if even x
  then func x
  else x

-- ifEvenDouble = ifEvenDo (\x -> 2 * x)
ifEvenDouble = ifEvenDo (2 *)

-- ifEvenInc = ifEvenDo (\x -> x + 1)
ifEvenInc = ifEvenDo (+ 1)
```
- Функции можно возвращать как результат функции

# Курс "Функциональное программирование на Haskell" от Д. Москвина (Stepik)

## 1. Введение

### 1.2. Функции
- Частичное применение функций:
```haskell
max5' = max 5 -- максимум между 5 и аргументом функции

-- Порядок аргументов выбран такой, чтобы удобно было
-- использовать частичное определение функции ниже:
discount thresh perc price
  | price >= thresh = price * (100 - perc) / 100
  | otherwise = price

-- Определение функции через частичное применение функции:
standardDiscount = discount 1000 5
```

- Аннотации функций - нет разделения между типами аргументов и типом возвращаемого значения, т.к. на самом деле все функции принимают одно значение
```haskell
makeAddress :: Int -> String -> String -> (Int, String, String)
makeAddress number street town = (number, street, town)

-- как ее видит Haskell:
makeAddressReal = (
  \number ->
    (\street ->
      (\town ->
        (number, street, town))))
```