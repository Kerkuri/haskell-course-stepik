module ParametricPoly where
import Data.Function
-- Про функцию говорят, что она обладает полиморфным поведением,
-- если она может быть вызвана на значениях разных типов.
-- Пример: оператор сложения "+"
-- 
-- Выделяют два типа полиморфизма: ПАРАМЕТРИЧЕСКИЙ и СПЕЦИАЛЬНЫЙ.
-- ПАРАМЕТРИЧЕСКИЙ полиморфизм - код функции одинаков для всех типов.
-- СПЕЦИАЛЬНЫЙ полиморфизм - для каждого типа есть своя реализация. Пример: оператор сложения (для Integer и Double разный код)

-- ПРИМЕР полиморфной параметрически функции:
-- нет никакого ограничения на тип аргумента:
id x = x
-- Тип функции id : тип аргументов и тип результата - произволен
-- ParametricPoly.id :: p -> p

-- Здесь интересно: работает транзитивность типов:
-- :t (id id)
-- id :: p -> p

-- ПРИМЕР полиморфной функции с двумя аргументами:
id2 x y = x
-- :t (id2 id2)
-- id2 :: p1 -> p2 -> p1

-- У id2 есть аналог в стандарной библиотеке - const
-- const :: a -> b -> a

-- ПРИМЕР константы полиморфного типа:
-- undefined :: GHC.Stack.Types.HasCallStack => a
-- Т.е. константу undefined можно использовать в ВЫРАЖЕНИИ ЛЮБОГО ТИПА

-- Аналогично себя ведет error:
-- :t error 
-- Принимает строковую константу и возвращает произвольный тип 'a':
-- error :: GHC.Stack.Types.HasCallStack => [Char] -> a
-- :t error "AAA"
-- error "AAA" :: a

getSecondFrom x1 x2 x3 = x2

weird :: a -> a -> b -> a -> a
weird x1 x2 x3 x4 = x1


-- СТЕПЕНЬ полиморфизма функции можно ограничить:

-- аналог id выше, но работает только с конкретным типом:
mono :: Char -> Char
mono x = x

-- ПРИМЕР ЧАСТИЧНО ОГРАНИЧЕННОГО ПОЛИМОРФИЗМА.
-- задание аргумента произвольного типа:
semiMono :: Char -> p1 -> Char
semiMono x y = x


-- ФУНКЦИИ ВЫСШИХ ПОРЯДКОВ
-- Функция высшего порядка - это функция, которая принимает в качестве аргумента другую функцию.
-- Пример такой функции - оператор $:
-- ($) :: (a -> b) -> a -> b

-- пример 1
apply2 :: (a -> a) -> a -> a
apply2 f x = f $ f x

-- пример 2
-- flip :: (a -> b -> c) -> b -> a -> c
-- flip f x y = f y x

flipConst :: a -> b -> b
flipConst = flip const

-- Полезная функция из Data.Function - применяет оператор op к f(x) и f(y):
-- on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
-- on op f x y = f x `op` f y

-- Через нее можно определить сумму квадратов так:
sumSquares = (+) `on` (^2)

-- Перемножение вторых элементов пар:
multSecond :: (a, Double) -> (a, Double) -> Double
multSecond = (*) `on` snd

-- ЛЯМБДА-ФУНКЦИИ
-- пример 1
f = \x -> 2 * x + 7
-- Обратная косая черта "\" читается как "лямбда"

-- пример 2
-- длина вектора на плоскости
len2dVec x y = sqrt $ x^2 + y^2

len2dVec' = \x -> \y -> sqrt $ x^2 + y^2
-- Версия с синтаксическим сахаром:
len2dVec'' = \x y -> sqrt $ x^2 + y^2


-- пример 3
-- суммируем первые элементы пары пар
p1 = ((1, 2), (3, 4))
p2 = ((3, 4), (5, 6))

sumFstFst = (+) `on` fstFst where
  fstFst pp = fst $ fst pp

sumFstFst' = (+) `on` (\pp -> fst $ fst pp)

on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = op (f x) (f y) (f z)

sum3squares = (\x y z -> x + y + z) `on3` (^2) 
