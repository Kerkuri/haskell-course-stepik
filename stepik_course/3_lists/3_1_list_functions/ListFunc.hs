module ListFunc where
-- import Prelude hiding (length, (++), null)
import Prelude hiding ((!!))

-- Списки в функциональных языках программирования играют
-- фундаментальную роль - аналогичную массивам в императивных
-- языках программирования.
--
-- Массивы в императивных языках программирования
-- выражают базовую идею распределенной изменяемой памяти,
-- нарезанной на некоторые кусочки, в которых хранятся
-- элементы этого массива.
--
-- Списки в функциональных языках программирования выражают
-- тоже важную фундаментальную идею о рекурсивных типах данных.
--
-- Списки для функционального программирования - самый базовый
-- контейнерный тип.
--
-- КОНСТРУКЦИЯ СПИСКОВ
-- Все способы задать списки в Haskell выражаются через
-- два следующих базовых способа:
-- 1) Создать пустой список:
_ = []
-- 2) Добавить элемент в голову уже существующего списка.
_ = 3 : []
-- NB: оператор (:) - правоассоциативный

-- ЗАДАНИЕ:
-- Реализуйте функцию addTwoElements,
-- которая бы добавляла два переданных ей значения
-- в голову переданного списка.
addTwoElements :: a -> a -> [a] -> [a]
addTwoElements x y lst = x : y : lst

-- ЗАДАНИЕ:
-- Реализуйте функцию nTimes, которая возвращает список,
-- состоящий из повторяющихся значений ее первого аргумента.
-- Количество повторов определяется значением второго аргумента
-- этой функции.
nTimes :: a -> Int -> [a]
-- ОТВЕТ:
-- Рекурсивное решение: падает по Memory limit
-- nTimes value n = accAdd value n []
--   where
--     accAdd value 1 acc = value : acc
--     accAdd value n acc = accAdd value (n - 1) $! (value : acc)
--
-- Решение через встроенные функции:
nTimes value n = take n (repeat value)
--
-- Решение через композицию:
{-
nTimes _ 0 = []
nTimes value n = (value :) . nTimes value $ n - 1
-}
-- Решение через форсирование вычислений:
{-
nTimes value 0 = []
nTimes value n = (value :) $ nTimes value (n - 1)
-}

-- ДЕКОНСТРУКЦИЯ СПИСКОВ
-- Получить первый элемент списка - функция head
_ = head [1, 2, 3] -- вернет 1
-- Получить все элементы кроме первого - функция tail
_ = tail [1, 2, 3] -- вернет [2, 3]

-- ПРИМЕР:
-- получить второй элемент списка
second :: [a] -> a
second = head . tail
-- аналог с аргументом:
-- second xs = head (tail xs)
-- Но лучше по возможности писать
-- в бесточечном стиле (без аргумента)
-- "Любой хаскелист поймет"

-- Еще один способ деконструкции списка - это
-- сопоставление с образцом (распаковка).
-- В качестве образцов используются аргументы,
-- которыми параметризован конструктор списков:
head' (x : xs) = x -- достаем первый элемент из конструктора
second' (_ : x : _) = x
tail' (_ : xs) = xs

-- ЗАДАНИЕ:
-- Исследуйте тип функции
sndHead = snd . head
-- и разберитесь, каково ее поведение.
-- Эту функцию можно реализовать, используя
-- сопоставление с образцом:
-- sndHead некоторый_образец = x
-- Отметьте те образцы, которые подходят для этой цели.
-- ОТВЕТ:
-- ((:) ((,) _ x) y)
-- ((,) y x : z)
-- ((_, x) : _)

-- Другой способ деконструкции списка - рекурсивный перебор.
-- ПРИМЕР:
-- определение длины списка рекурсивно:
{-length :: [a] -> Int-}
{-length [] = 0-}
{-length (_ : xs) = 1 + length xs-}

-- ПРИМЕР:
-- конкатенация двух списков через рекурсию:
{-(++) :: [a] -> [a] -> [a]-}
{-[] ++ ys = ys-}
{-(x : xs) ++ ys = x : xs ++ ys-}

-- ПРИМЕР:
-- проверка, что список пустой:
{-null :: [a] -> Bool-}
{-null [] = True-}
{-null _ = False-}

-- ЗАДАНИЕ:
-- Сформируйте список целых чисел,
-- содержащий только те элементы исходного списка,
-- значение которых нечетно.
oddsOnly :: Integral a => [a] -> [a]
oddsOnly [] = []
oddsOnly lst = [x | odd x] ++ oddsOnly (tail lst)
  where
    x = head lst

-- Условием остановки при рекурсивной деконструкции
-- списков может быть не только пустой список.
-- ПРИМЕР:
-- получить последний элемент списка:
last' :: [a] -> a
last' (x : []) = x
last' (_ : xs) = last' xs


-- ПРИМЕР:
-- получить исходный список без последнего элемента
-- (tail, но наоборот):
init' :: [a] -> [a]
init' [_] = []
init' (x : xs) = x : init xs

-- ПРИМЕР:
-- сумма элементов списка:
sum' :: Num a => [a] -> a
sum' [] = 0
sum' (x : xs) = x + sum' xs
-- NB: более лаконичный аналог (тру хаскелл):
--sum' = foldr (+) 0 

-- ПРИМЕР:
-- произведение элементов списка:
product' :: Num a => [a] -> a
product' = foldr (*) 1

-- ПРИМЕР:
-- максимум элементов списка:
maximum' :: Ord a => [a] -> a
maximum' [x] = x
maximum' (firstElem : tailLst) = max firstElem $ maximum' tailLst

-- ПРИМЕР:
-- минимум элементов списка:
minimum' :: Ord a => [a] -> a
minimum' [x] = x
minimum' (firstElem : tailLst) = min firstElem $ minimum' tailLst

-- ПРИМЕР:
-- разворачивание списка:
reverse' :: [a] -> [a]
reverse' lst = rev lst [] where
  rev [] acc = acc
  rev (firstElem : tailLst) acc = rev tailLst (firstElem : acc)

-- ЗАДАНИЕ:
-- Реализуйте функцию isPalindrome, которая определяет,
-- является ли переданный ей список палиндромом.
-- ОТВЕТ:
isPalindrome :: Eq a => [a] -> Bool
isPalindrome lst = lst == reverse lst

-- Еще одна схема рекурсии: сопоставление с более
-- чем 1 образцом:
-- ПРИМЕР:
-- упаковать два списка в список пар:
zip' :: [a] -> [b] -> [(a, b)]
zip' [] _ = []
zip' _ [] = []
zip' (a : as) (b : bs) = (a, b) : zip' as bs

-- ПРИМЕР:
-- распаковать список пар в два списка:
unzip' :: [(a, b)] -> ([a], [b])
unzip' [] = ([], [])
unzip' ((x, y) : xys) = (x : xs, y : ys) where
  (xs, ys) = unzip' xys

-- ЗАДАНИЕ:
-- Составьте список сумм соответствующих элементов
-- трех заданных списков. Длина результирующего списка
-- должна быть равна длине самого длинного из заданных списков,
-- при этом «закончившиеся» списки не должны давать вклада в суммы.
-- sum3 [1,2,3] [4,5] [6]
-- [11,7,3]
-- ОТВЕТ:
sum3 :: Num a => [a] -> [a] -> [a] -> [a]
sum3 lst1 lst2 lst3 =
  let 
    n = max (length lst1) $ max (length lst2) (length lst3)
    lst1Ext = lst1 ++ (take (n - length lst1) $ repeat 0)
    lst2Ext = lst2 ++ (take (n - length lst2) $ repeat 0)
    lst3Ext = lst3 ++ (take (n - length lst3) $ repeat 0)
  in map (\(x, y, z) -> x + y + z) (zip3 lst1Ext lst2Ext lst3Ext)
-- Вариант от авторов курса:
sum3' xs ys zs = xs `sum2` ys `sum2` zs
  where
    sum2 [] bs = bs
    sum2 as [] = as
    sum2 (a : as) (b : bs) = (a + b) : sum2 as bs

-- ЗАДАНИЕ:
-- Напишите функцию groupElems которая группирует
-- одинаковые элементы в списке (если они идут подряд)
-- и возвращает список таких групп.
-- GHCi> groupElems []
-- []
-- GHCi> groupElems [1,2]
-- [[1],[2]]
-- GHCi> groupElems [1,2,2,2,4]
-- [[1],[2,2,2],[4]]
-- GHCi> groupElems [1,2,3,2,4]
-- [[1],[2],[3],[2],[4]]
-- ОТВЕТ:
groupElems :: Eq a => [a] -> [[a]]
groupElems = helper []
  where
    helper acc [] = acc
    helper [] (headElem : tailLst) = helper [[headElem]] tailLst
    helper acc (headElem : tailLst)
      | last (last acc) == headElem = let
          newAcc = init acc ++ [last acc ++ [headElem]]
          in helper newAcc tailLst
      | otherwise = helper (acc ++ [[headElem]]) tailLst


-- Функции работы со списками:
-- 1) take - взять первых n элементов списка:
take' :: Int  -> [a] -> [a]
take' n _ | n <= 0 = []
take' _ [] = []
take' n (x : xs) = x : take (n - 1) xs
-- 2) drop - вернуть список с выброшенными первыми n элементами:
drop' :: Int -> [a] -> [a]
drop' n xs | n <= 0 = xs
drop' _ [] = []
drop' n (_ : xs) = drop (n - 1) xs
-- 3) splitAt - разрезает список на две части, поместив в первую часть N элементов)
splitAt' :: Int -> [a] -> ([a], [a])
splitAt' n xs = (take' n xs, drop' n xs)
-- !!! NB: при работе со списками в Haskell довольно редко используется явная рекурсия.
-- Вместо этого лучше использовать уже готовые стандартные функции для работы со списками.
-- Явная рекурсия обычно есть только в низкоуровневых стандартных функциях.
-- 4) Взятие элемента по индексу:
xs !! n | n < 0 = error "Prelude.!!: ty che pes! negative index"
[] !! _  = error "Prelude.!!: ty che pes! index too large"
(x : _) !! 0 = x
(_ : xs) !! n = xs !! (n - 1)
-- NB: да, здесь взятие по индексу - это O(n)
-- Но если нужно быстрее, то нужно использовать другой тип контейнера
