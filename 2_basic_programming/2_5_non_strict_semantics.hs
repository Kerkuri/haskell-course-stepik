module Demo where
import GHC.Exts.Heap (ClosureType(THUNK))
-- В императивных языках порядок вычислений определяется последовательностью инструкций.
-- В функциональных языках инструкций нет, поэтому порядок определяется иначе.
-- Вычисления в функциональных языках происходят посредством РЕДУКЦИИ ВЫРАЖЕНИЙ.

-- Ленивая редукция выражений в Haskell
sumIt :: Int -> Int -> Int
sumIt x y = x + y

{-
-- При вызове функции происходит подстановка тела функции:
sumIt (2 + 3) 4
  ~> (2 + 3) + 4
-- А только потом - вычисление:
  ~> 5 + 4
  ~> 9
-}

-- Выражение, которое может быть непосредственно упрощено, называется РЕДЕКСОМ (REDEX).
-- В 11-й строке два РЕДЕКСА: (2 + 3) и применение функции sumIt к своим аргументам.

-- ЗАДАНИЕ:
-- Предположим, что стандартные функции определены следующим образом:
{-
id x = x
const x y = x
max x y = if x <= y then y else x
infixr 0 $
f $ x = f x
-}
-- Сколько редексов имеется в следующем выражении?
-- const $ const (4 + 5) $ max 42
--
-- ПРИМЕЧАНИЕ:
-- Мы определили шаг вычислений как подстановку тела функции вместо ее имени
-- с заменой ВСЕХ ее формальных параметров на фактически переданные ей выражения.
-- РЕДЕКСОМ называем подвыражение, над которым можно осуществить подобный шаг.
--
-- ОТВЕТ: 3 = второй $, (4 + 5), второй const.
-- Остальные вызовы функций редексами не являются, потому что у них не полный набор аргументов.

-- ПРЕИМУЩЕСТВО ленивой модели вычислений на примере:
-- Пусть есть функция, которая прибавляет 7 к первому аргументы и игнорирует второй аргумент:
add7 :: Int -> Int -> Int
add7 x y = x + 7

-- Как она будет вычисляться в ленивой модели:
{-
add7 1 (2 + 3)
  ~> 1 + 7
  ~> 8
-}

-- Как она будет вычисляться в энергичной модели:
{-
add7 1 (2 + 3)
  ~> add7 1 5
  ~> 1 + 7
  ~> 8
-}

-- ПРИМЕР, когда ленивая модель может быть неэффективной:
dup :: Int -> (Int, Int)
dup x = (x, x)
-- Как она будет вычисляться в ленивой модели:
{-
dup (2+3)
  ~> (2+3, 2+3)
  ~> (5, 2+3)
  ~> (5, 5)
-}

-- Как она будет вычисляться в энергичной модели:
{-
dup (2+3)
  ~> dup 5
  ~> (5, 5)
-}

-- Как с этим борются в Haskell:
-- В Haskell есть МЕХАНИЗМ РАЗДЕЛЕНИЯ - при редукции выражения происходит следующее:
{-
dup (2+3)
  ~> (p, p)       p = 2 + 3
  -- p - указатель на область памяти,
  -- где может храниться ОТЛОЖЕННОЕ ВЫЧИСЛЕНИЕ (THUNK) или просто значение
  ~> (p, p)       p = 5
  ~> (5, 5)
-}
-- Этот механизм, однако, делает структуру выражения более сложной для понимания,
-- ведь на самом деле это не дерево, а граф.
-- И процесс редукции - это процесс сокращения этого графа до тех пор,
-- пока в этом графе не останется редексов.

--
-- ЗАДАНИЕ:
-- Сколько шагов редукции потребуется,
-- чтобы вычислить значение функции value,
-- если используется ленивая стратегия вычислений с механизмом разделения?
bar x y z = x + y
foo a b = bar a a (a + b)
value = foo (3 * 10) (5 - 2)
-- Примечание: Подстановку тела функции value вместо value не считайте.
-- ОТВЕТ: 4.
-- foo (3 * 10) (5 - 2) -- вот эту подстановку не считаем
-- bar (3 * 10) (3 * 10) (5 - 2)
-- (3 * 10) + (3 * 10)
-- 30 + 30
-- 60

-- Интересный эффект ленивой модели вычислений:
-- эта модель может элиминировать во многих случаях незавершаемость программ.
-- ПРИМЕР:
const42 :: a -> Int 
const42 = const 42
-- Аргумент этой функции не влияет на ее работу, поэтому в качестве аргумента
-- можно передавать любую, даже незавершающуюся программу, или даже такое:
_ = const42 undefined
-- undefined прерывает программу при вызове, но этот код не упадет,
-- потому что const42 не обратится к этому аргументу.

-- const42 - пример нестрогой функции. 
-- НЕСТРОГАЯ функция определяется следующим образом:
-- аргумент - расходящее вычисление, результат - нерасходящееся значение.
--
-- СТРОГАЯ функция определяется наоборот: 
-- если аргумент - расходящее вычисление, то и результат - расходящее значение.

-- ЗАДАНИЕ:
-- Отметьте функции, которые не могут привести к расходимости ни на каком корректном наборе аргументов.
-- NB: нестрогость можно проверять по тому,
-- уйдет ли функция в бесконечный цикл
-- или выкинет ли exception при передаче в нее любых аргументов, включая undefined.

foo' a = a -- упадет при a = undefined

bar' = const foo' -- упадет, если второй аргумент будет undefined. (Но если первый, то не упадет)
-- вообще тут интересно подставляются аргументы:
-- bar' x y = const foo' x y = foo' y -- игнорируется первый аргумент

baz x = const True -- не упадет и не уйдет в бесконечный цикл, т.к. игнорирует оба своих аргумента (первый - x, второй от const)

quux = let x = x in x -- бесконечный цикл

corge = "Sorry, my value was changed" -- не упадет, потому что не принимает аргументов

grault x 0 = x
grault x y = x -- упадет, если второй аргумент undefined.
-- Это происходит, т.к. будет происходить проверка на равенство y и 0

garply = grault 'q' -- аналогично grault

waldo = foo' -- аналогично foo'

-- СЛАБАЯ ГОЛОВНАЯ НОРМАЛЬНАЯ ФОРМА ВЫРАЖЕНИЙ (WHNF)
-- Вычисления в Haskell происходят путем редукции выражений.
-- Редукция происходит до тех пор, пока выражение не примет НОРМАЛЬНУЮ ФОРМУ (NF).
-- Выражение имеет НОРМАЛЬНУЮ ФОРМУ, если в нем нет редексов (redex).
-- ПРИМЕР выражений в нормальной форме:
{-
42
(3, 4)
-- функции тоже могут быть в нормальной форме,
-- когда для них невозможно провести никаких вычислений:
\x -> x + 2 -- оператор (+) можно вычислять, только когда вычислены все его аргументы
-}

-- ПРИМЕР выражений НЕ в нормальной форме:
{-
"Real " ++ "world"
sin (pi / 2)
(\x -> x + 2) 5
(3, 1 + 5)
-}

-- ПРИМЕР СЛАБОЙ ГОЛОВНОЙ НОРМАЛЬНОЙ ФОРМЫ:
-- В WHNF выражения, находящиеся в одном из следующих трех видов:
{-
-- 1) Любая лямбда-абстракция:
-- \x -> x + 2*3 -- не нормальная форма, потому что есть редекс 2*3
-- Т.е. когда есть редексы "за барьером" лямбда-абстракции, то это WHNF
-}
{-
-- 2) Конструктор данных:
-- (3, 1 + 5)
-- (, 4*5) -- в том числе частично примененный конструктор данных
-}
{-
-- 3) Частично примененная встроенная функция:
-- (+) (7^2)
-- если бы здесь была не встроенная, а определенная пользователем функция,
-- то можно было бы произвести частичную редукцию, поэтому WHNF не было бы.
-}
-- Выражения, которые находятся в WHNF, находятся и NF.
-- Т.е. WHNF расширяет NF

-- Во многих случаях вычисления в Haskell останавливаются на WHNF.
-- Это позволяет сделать функции еще более определенными в случае расходимости.

-- ПРОБЛЕМА ЛЕНИВОЙ МОДЕЛИ ВЫЧИСЛЕНИЙ
-- При длинной цепочке вычислений может накопиться большой объем
-- отложенных вычислений (THUNK), что может привести к утечками памяти (THUNK LEAK).
-- Для борьбы с этим в Haskell есть вычислительный примитив seq.
-- seq нарушает ленивую семантику Haskell: когда мы им пользуемся,
-- вычисления перестают быть ленивыми.

-- Как примерно устроен seq:
{-
seq :: a -> b -> b
-- _|_ -- специальная конструкция - "основание", которое означает расходящее вычисление
seq _|_ b = _|_ -- если первый аргумент расходится, то результат должен расходиться
seq a b = b -- если первый аргумент не расходится, но возвращает второй аргумент
-}
-- seq форсирует вычисление своего первого аргумента до WHNF:
_ = seq undefined 1 -- упадет
_ = seq (undefined, undefined) 1 -- вернет 1

-- ЗАДАНИЕ:
-- При вычислении каких из перечисленных ниже функций использование seq
-- предотвратит нарастание количества невычисленных редексов
-- при увеличении значения первого аргумента:

-- Здесь нет лишних вычислений,
-- поэтому seq ни на что не влияет
foo'' 0 x = x
foo'' n x = let
  x' = foo'' (n - 1) (x + 1)
  in x' `seq` x'

-- Здесь f - лямбда-абстракция, т.е. она уже в WHNF.
-- Вычисление f' ничего не даст:
bar'' 0 f = f
bar'' x f = let
  f' = \a -> f (x + a)
  x' = x - 1
  in f' `seq` x' `seq` bar'' x' f'

-- Здесь p уже в WHNF, поэтому seq ни на что не повлияет:
baz'' 0 (x, y) = x + y
baz'' n (x, y) = let
  x' = x + 1
  y' = y - 1
  p  = (x', y')
  n' = n - 1
  in p `seq` n' `seq` baz'' n' p

-- А вот здесь seq пресекает THUNK LEAK,
-- поэтому функция работает быстрее:
quux'' 0 (x, y) = x + y
quux'' n (x, y) = let
  x' = x + 1
  y' = y - 1
  p  = (x', y')
  n' = n - 1
  in x' `seq` y' `seq` n' `seq` quux'' n' p
-- ОТВЕТ: quux
-- см. аналоги функций без seq в файле 2_5_seq_task.hs,
-- засеки время их работы и сравни

-- Более удобный в использовании АНАЛОГ seq.
-- Оператор ($!) (применение с вызовом по значению):
{-
($!) :: (a -> b) -> a -> b
f $! x = x `seq` f x -- форсирует вычисление x и передает его в f
-}
-- Т.е. это аналог $, который форсирует вычисление аргумента функции:
_ = const 1 $ undefined -- не упадет
_ = const 1 $! undefined -- упадет

-- Оператор ($!) нужен, чтобы в длинной цепочке вычислений
-- не накапливались отложенные вычисления (THUNK)

-- ПРИМЕР с накоплением отложенных вычислений:
factorial :: Integer -> Integer
factorial n
  | n >= 0 = helper 1 n
  | otherwise = error "arg must be >= 0"
  where
    helper acc 0 = acc
    -- в этой строке будут накапливаться отложенные вычисления acc * n:
    -- helper acc n = helper (acc * n) (n - 1)
    -- Понятное дело, что встроенный анализатор Haskell в таком простом случае справится сам,
    -- но если мы не уверены или если хотим избавиться от длинной цепочки вычислений,
    -- то можно определить применение helper к своему первому аргументу как строгое:
    helper acc n = (helper $! (acc * n)) (n - 1) -- у $! низкий приоритет, поэтому нужны скобки
-- В этой версии factorial нет цепочки вычислений:
-- на каждом шаге (acc * n) будет вычисляться и только потом передаваться в helper

-- ЗАДАНИЕ:
-- Ниже определены функции mySum и goSum.
-- Вызов goSum может выглядеть, к примеру, так:  goSum 15.
-- Выберите верные утверждения, описывающие процесс вычисления подобного выражения.
mySum acc 0 = acc
mySum (result, ()) n = (mySum $! (result + n, ())) $ n - 1

goSum = mySum (0, ())

-- ОТВЕТ:
--
-- 1) В первом аргументе функции mySum будут накапливаться отложенные вычисления.
--
-- Оператор $! ни на что не повлияет, т.к. первый аргумент - конструктор данных,
-- т.е. он в WHNF, его вычисление не будет форсироваться.
--
-- 2) Во втором аргументе функции mySum не будут накапливаться отложенные вычисления,
-- так как при каждом рекурсивном вызове происходит сопоставление с 0.
