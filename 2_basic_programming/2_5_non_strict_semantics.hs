module Demo where
-- В императивных языках порядок вычислений определяется последовательностью инструкций.
-- В функциональных языках инструкций нет, поэтому порядок определяется иначе.
-- Вычисления в функциональных языках происходят посредством РЕДУКЦИИ ВЫРАЖЕНИЙ.

-- Ленивая редукция выражений в Haskell
sumIt :: Int -> Int -> Int
sumIt x y = x + y

{-
-- При вызове функции происходит подстановка тела функции:
sumIt (2 + 3) 4
  ~> (2 + 3) + 4
-- А только потом - вычисление:
  ~> 5 + 4
  ~> 9
-}

-- Выражение, которое может быть непосредственно упрощено, называется РЕДЕКСОМ (REDEX).
-- В 11-й строке два РЕДЕКСА: (2 + 3) и применение функции sumIt к своим аргументам.

-- ЗАДАНИЕ:
-- Предположим, что стандартные функции определены следующим образом:
{-
id x = x
const x y = x
max x y = if x <= y then y else x
infixr 0 $
f $ x = f x
-}
-- Сколько редексов имеется в следующем выражении?
-- const $ const (4 + 5) $ max 42
--
-- ПРИМЕЧАНИЕ:
-- Мы определили шаг вычислений как подстановку тела функции вместо ее имени
-- с заменой ВСЕХ ее формальных параметров на фактически переданные ей выражения.
-- РЕДЕКСОМ называем подвыражение, над которым можно осуществить подобный шаг.
--
-- ОТВЕТ: 3 = второй $, (4 + 5), второй const.
-- Остальные вызовы функций редексами не являются, потому что у них не полный набор аргументов.

-- ПРЕИМУЩЕСТВО ленивой модели вычислений на примере:
-- Пусть есть функция, которая прибавляет 7 к первому аргументы и игнорирует второй аргумент:
add7 :: Int -> Int -> Int
add7 x y = x + 7

-- Как она будет вычисляться в ленивой модели:
{-
add7 1 (2 + 3)
  ~> 1 + 7
  ~> 8
-}

-- Как она будет вычисляться в энергичной модели:
{-
add7 1 (2 + 3)
  ~> add7 1 5
  ~> 1 + 7
  ~> 8
-}
