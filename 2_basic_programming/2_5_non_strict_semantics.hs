module Demo where
-- В императивных языках порядок вычислений определяется последовательностью инструкций.
-- В функциональных языках инструкций нет, поэтому порядок определяется иначе.
-- Вычисления в функциональных языках происходят посредством РЕДУКЦИИ ВЫРАЖЕНИЙ.

-- Ленивая редукция выражений в Haskell
sumIt :: Int -> Int -> Int
sumIt x y = x + y

{-
-- При вызове функции происходит подстановка тела функции:
sumIt (2 + 3) 4
  ~> (2 + 3) + 4
-- А только потом - вычисление:
  ~> 5 + 4
  ~> 9
-}

-- Выражение, которое может быть непосредственно упрощено, называется РЕДЕКСОМ (REDEX).
-- В 11-й строке два РЕДЕКСА: (2 + 3) и применение функции sumIt к своим аргументам.

-- ЗАДАНИЕ:
-- Предположим, что стандартные функции определены следующим образом:
{-
id x = x
const x y = x
max x y = if x <= y then y else x
infixr 0 $
f $ x = f x
-}
-- Сколько редексов имеется в следующем выражении?
-- const $ const (4 + 5) $ max 42
--
-- ПРИМЕЧАНИЕ:
-- Мы определили шаг вычислений как подстановку тела функции вместо ее имени
-- с заменой ВСЕХ ее формальных параметров на фактически переданные ей выражения.
-- РЕДЕКСОМ называем подвыражение, над которым можно осуществить подобный шаг.
--
-- ОТВЕТ: 3 = второй $, (4 + 5), второй const.
-- Остальные вызовы функций редексами не являются, потому что у них не полный набор аргументов.

-- ПРЕИМУЩЕСТВО ленивой модели вычислений на примере:
-- Пусть есть функция, которая прибавляет 7 к первому аргументы и игнорирует второй аргумент:
add7 :: Int -> Int -> Int
add7 x y = x + 7

-- Как она будет вычисляться в ленивой модели:
{-
add7 1 (2 + 3)
  ~> 1 + 7
  ~> 8
-}

-- Как она будет вычисляться в энергичной модели:
{-
add7 1 (2 + 3)
  ~> add7 1 5
  ~> 1 + 7
  ~> 8
-}

-- ПРИМЕР, когда ленивая модель может быть неэффективной:
dup :: Int -> (Int, Int)
dup x = (x, x)
-- Как она будет вычисляться в ленивой модели:
{-
dup (2+3)
  ~> (2+3, 2+3)
  ~> (5, 2+3)
  ~> (5, 5)
-}

-- Как она будет вычисляться в энергичной модели:
{-
dup (2+3)
  ~> dup 5
  ~> (5, 5)
-}

-- Как с этим борются в Haskell:
-- В Haskell есть МЕХАНИЗМ РАЗДЕЛЕНИЯ - при редукции выражения происходит следующее:
{-
dup (2+3)
  ~> (p, p)       p = 2 + 3
  -- p - указатель на область памяти,
  -- где может храниться ОТЛОЖЕННОЕ ВЫЧИСЛЕНИЕ (THUNK) или просто значение
  ~> (p, p)       p = 5
  ~> (5, 5)
-}
-- Этот механизм, однако, делает структуру выражения более сложной для понимания,
-- ведь на самом деле это не дерево, а граф.
-- И процесс редукции - это процесс сокращения этого графа до тех пор,
-- пока в этом графе не останется редексов.

--
-- ЗАДАНИЕ:
-- Сколько шагов редукции потребуется,
-- чтобы вычислить значение функции value,
-- если используется ленивая стратегия вычислений с механизмом разделения?
bar x y z = x + y
foo a b = bar a a (a + b)
value = foo (3 * 10) (5 - 2)
-- Примечание: Подстановку тела функции value вместо value не считайте.
-- ОТВЕТ: 4.
-- foo (3 * 10) (5 - 2) -- вот эту подстановку не считаем
-- bar (3 * 10) (3 * 10) (5 - 2)
-- (3 * 10) + (3 * 10)
-- 30 + 30
-- 60

-- Интересный эффект ленивой модели вычислений:
-- эта модель может элиминировать во многих случаях незавершаемость программ.
-- ПРИМЕР:
const42 :: a -> Int 
const42 = const 42
-- Аргумент этой функции не влияет на ее работу, поэтому в качестве аргумента
-- можно передавать любую, даже незавершающуюся программу, или даже такое:
_ = const42 undefined
-- undefined прерывает программу при вызове, но этот код не упадет,
-- потому что const42 не обратится к этому аргументу.

-- const42 - пример нестрогой функции. 
-- НЕСТРОГАЯ функция определяется следующим образом:
-- аргумент - расходящее вычисление, результат - нерасходящееся значение.
--
-- СТРОГАЯ функция определяется наоборот: 
-- если аргумент - расходящее вычисление, то и результат - расходящее значение.

-- ЗАДАНИЕ:
-- Отметьте функции, которые не могут привести к расходимости ни на каком корректном наборе аргументов.
-- NB: нестрогость можно проверять по тому,
-- уйдет ли функция в бесконечный цикл
-- или выкинет ли exception при передаче в нее любых аргументов, включая undefined.

foo' a = a -- упадет при a = undefined

bar' = const foo' -- упадет, если второй аргумент будет undefined. (Но если первый, то не упадет)
-- вообще тут интересно подставляются аргументы:
-- bar' x y = const foo' x y = foo' y -- игнорируется первый аргумент

baz x = const True -- не упадет и не уйдет в бесконечный цикл, т.к. игнорирует оба своих аргумента (первый - x, второй от const)

quux = let x = x in x -- бесконечный цикл

corge = "Sorry, my value was changed" -- не упадет, потому что не принимает аргументов

grault x 0 = x
grault x y = x -- упадет, если второй аргумент undefined.
-- Это происходит, т.к. будет происходить проверка на равенство y и 0

garply = grault 'q' -- аналогично grault

waldo = foo' -- аналогично foo'

-- СЛАБАЯ ГОЛОВНАЯ НОРМАЛЬНАЯ ФОРМА ВЫРАЖЕНИЙ (WHNF)
-- Вычисления в Haskell происходят путем редукции выражений.
-- Редукция происходит до тех пор, пока выражение не примет НОРМАЛЬНУЮ ФОРМУ (NF).
-- Выражение имеет НОРМАЛЬНУЮ ФОРМУ, если в нем нет редексов (redex).
-- ПРИМЕР выражений в нормальной форме:
{-
42
(3, 4)
-- функции тоже могут быть в нормальной форме,
-- когда для них невозможно провести никаких вычислений:
\x -> x + 2 -- оператор (+) можно вычислять, только когда вычислены все его аргументы
-}

-- ПРИМЕР выражений НЕ в нормальной форме:
{-
"Real " ++ "world"
sin (pi / 2)
(\x -> x + 2) 5
(3, 1 + 5)
-}

-- ПРИМЕР СЛАБОЙ ГОЛОВНОЙ НОРМАЛЬНОЙ ФОРМЫ:
-- В WHNF выражения, находящиеся в одном из следующих трех видов:
{-
-- 1) Любая лямбда-абстракция:
-- \x -> x + 2*3 -- не нормальная форма, потому что есть редекс 2*3
-- Т.е. когда есть редексы "за барьером" лямбда-абстракции, то это WHNF
-}
{-
-- 2) Конструктор данных:
-- (3, 1 + 5)
-- (, 4*5) -- в том числе частично примененный конструктор данных
-}
{-
-- 3) Частично примененная встроенная функция:
-- (+) (7^2)
-- если бы здесь была не встроенная, а определенная пользователем функция,
-- то можно было бы произвести частичную редукцию, поэтому WHNF не было бы.
-}
-- Выражения, которые находятся в WHNF, находятся и NF.
-- Т.е. WHNF расширяет NF

-- Во многих случаях вычисления в Haskell останавливаются на WHNF.
-- Это позволяет сделать функции еще более определенными в случае расходимости.
